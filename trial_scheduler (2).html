<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dog Agility Trial Scheduler</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4a86e8 0%, #357ae8 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .content {
            padding: 30px;
        }
        
        .upload-section {
            background: #f8f9fa;
            border: 3px dashed #4a86e8;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s;
        }
        
        .upload-section:hover {
            border-color: #357ae8;
            background: #f0f4ff;
        }
        
        .upload-section.dragover {
            background: #e3f2fd;
            border-color: #2196f3;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .upload-label {
            display: inline-block;
            background: #4a86e8;
            color: white;
            padding: 15px 40px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.3s;
        }
        
        .upload-label:hover {
            background: #357ae8;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 134, 232, 0.4);
        }
        
        .btn {
            background: #4a86e8;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            margin: 5px;
            transition: all 0.3s;
        }
        
        .btn:hover {
            background: #357ae8;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-success {
            background: #28a745;
        }
        
        .btn-success:hover {
            background: #218838;
        }
        
        .tabs {
            display: flex;
            border-bottom: 2px solid #e0e0e0;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 15px 30px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            font-weight: 500;
        }
        
        .tab:hover {
            background: #f5f5f5;
        }
        
        .tab.active {
            border-bottom-color: #4a86e8;
            color: #4a86e8;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        th {
            background: #4a86e8;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 10px 12px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        tr:hover {
            background: #f5f5f5;
        }
        
        .date-header {
            background: #e8f0fe;
            font-weight: bold;
            padding: 15px;
            margin-top: 20px;
            border-left: 4px solid #4a86e8;
        }
        
        .ring-section {
            margin-bottom: 30px;
        }
        
        .ring-header {
            background: #e8f0fe;
            padding: 10px 15px;
            font-weight: bold;
            border-left: 4px solid #4a86e8;
            margin-bottom: 10px;
        }
        
        .status-message {
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
            font-weight: 500;
        }
        
        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .grid-cell {
            text-align: center;
        }
        
        .grid-cell-filled {
            background: #d9ead3;
            font-weight: bold;
        }
        
        .incomplete-section {
            background: #f8d7da;
            border: 2px solid #ea4335;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .incomplete-section h3 {
            color: #721c24;
            margin-bottom: 15px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: #666;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4a86e8;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Judge dropdown styling */
        .judge-dropdown {
            width: 100%;
            padding: 6px 10px;
            border: 2px solid #4a86e8;
            border-radius: 4px;
            background: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .judge-dropdown:hover {
            border-color: #357ae8;
            box-shadow: 0 2px 4px rgba(74, 134, 232, 0.2);
        }
        
        .judge-dropdown:focus {
            outline: none;
            border-color: #357ae8;
            box-shadow: 0 0 0 3px rgba(74, 134, 232, 0.1);
        }
        
        .judge-dropdown option {
            padding: 8px;
        }
        
        /* Drag and drop styling */
        .draggable-class {
            cursor: move;
            user-select: none;
            position: relative;
            transition: all 0.2s;
        }
        
        .draggable-class:hover {
            background: #e3f2fd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .drag-handle {
            color: #999;
            margin-right: 8px;
            font-weight: bold;
        }
        
        .dragging {
            opacity: 0.5;
            background: #fff3cd;
            border: 2px dashed #ff9800;
        }
        
        .dragging-group {
            background: #fff3cd !important;
            border-left: 4px solid #ff9800 !important;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
        }
        
        .dragging-group::before {
            content: '‚Üî ';
            color: #ff9800;
            font-weight: bold;
        }
        
        .drop-zone.valid-drop {
            background: #c8e6c9 !important;
            border: 2px solid #4caf50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
        }
        
        .drop-zone.invalid-drop {
            background: #e0e0e0 !important;
            border: 2px solid #999;
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .drop-zone.drag-over {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .drop-zone.valid-drop.drag-over {
            background: #a5d6a7 !important;
        }
        
        .empty-drop-zone {
            min-height: 40px;
            border: 2px dashed #ddd;
            text-align: center;
        }
        
        .empty-drop-zone.valid-drop::after {
            content: '‚úì Drop here';
            color: #4caf50;
            font-weight: bold;
        }
        
        .non-first-round {
            background: #f5f5f5;
            color: #666;
            font-style: italic;
        }
        
        /* Touch drag ghost */
        #touch-drag-ghost {
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            border: 2px solid #ff9800;
            background: #fff3cd;
        }
        
        /* Scroll indicators */
        body.auto-scrolling-up::before,
        body.auto-scrolling-down::after {
            content: '‚ñ≤ Scrolling...';
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(74, 134, 232, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: bold;
            z-index: 9999;
            animation: pulse 1s infinite;
        }
        
        body.auto-scrolling-up::before {
            top: 10px;
            content: '‚ñ≤ Scrolling Up...';
        }
        
        body.auto-scrolling-down::after {
            bottom: 10px;
            content: '‚ñº Scrolling Down...';
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üêï Dog Agility Trial Scheduler</h1>
            <p>Automated 3-Ring Trial Scheduling System</p>
        </div>
        
        <div class="content">
            <div id="uploadSection" class="upload-section">
                <h2 style="margin-bottom: 20px;">Upload Trial Data</h2>
                <p style="margin-bottom: 20px; color: #666;">
                    Upload your Excel file with sheets: "Form Responses 1", "Judges", and "class and rounds"
                </p>
                <label for="fileInput" class="upload-label">
                    üìÅ Choose Excel File
                </label>
                <input type="file" id="fileInput" accept=".xlsx,.xls">
                <p id="fileName" style="margin-top: 15px; color: #666;"></p>
            </div>
            
            <div id="controlSection" style="display: none; text-align: center; margin-bottom: 30px;">
                <button id="generateBtn" class="btn">‚ö° Generate Schedule</button>
                <button id="exportBtn" class="btn btn-success" style="display: none;">üì• Export to Excel</button>
            </div>
            
            <div id="statusSection"></div>
            
            <div id="resultsSection" style="display: none;">
                <div class="tabs">
                    <div class="tab active" data-tab="schedule">üìÖ Schedule</div>
                    <div class="tab" data-tab="grid">üìä Round Distribution</div>
                    <div class="tab" data-tab="summary">üë• Judge Summary</div>
                </div>
                
                <div id="scheduleTab" class="tab-content active"></div>
                <div id="gridTab" class="tab-content"></div>
                <div id="summaryTab" class="tab-content"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let workbookData = null;
        let scheduleResult = null;
        
        // Configuration
        const CONFIG = {
            HIGH_LEVEL: ['Super Sleuth 4', 'Det Diversions', 'Private Inv'],
            RING2_ONLY: ['Ranger 4', 'Ranger 5', 'Dasher 5', 'Dasher 6'],
            RING3_ONLY: ['Patrol 1', 'Detective 2', 'Investigator 3', 'Ranger 1', 'Ranger 2'],
            FLEXIBLE_CLASSES: ['Dasher 3', 'Dasher 4', 'Ranger 3'],
            MAX_PURSUING_VIOLATIONS: 1,
            ROUNDS_PER_DAY: {
                'Patrol 1': 3,
                'Super Sleuth 4': 1,
                'Det Diversions': 1,
                'Private Inv': 1,
                'default': 2
            }
        };
        
        // File upload handling
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        
        fileInput.addEventListener('change', handleFileSelect);
        
        // Drag and drop
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });
        
        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });
        
        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                handleFile(file);
            }
        });
        
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        }
        
        function handleFile(file) {
            document.getElementById('fileName').textContent = `Selected: ${file.name}`;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    
                    // Verify required sheets exist
                    const requiredSheets = ['Form Responses 1', 'Judges', 'class and rounds'];
                    const missingSheets = requiredSheets.filter(sheet => !workbook.SheetNames.includes(sheet));
                    
                    if (missingSheets.length > 0) {
                        showStatus(`Missing required sheets: ${missingSheets.join(', ')}`, 'error');
                        return;
                    }
                    
                    workbookData = workbook;
                    document.getElementById('controlSection').style.display = 'block';
                    showStatus('File loaded successfully! Click "Generate Schedule" to begin.', 'success');
                    
                } catch (error) {
                    showStatus(`Error reading file: ${error.message}`, 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        // Generate button
        document.getElementById('generateBtn').addEventListener('click', generateSchedule);
        
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                const tabName = tab.getAttribute('data-tab');
                document.getElementById(`${tabName}Tab`).classList.add('active');
            });
        });
        
        function showStatus(message, type) {
            const statusSection = document.getElementById('statusSection');
            statusSection.innerHTML = `<div class="status-message status-${type}">${message}</div>`;
        }
        
        function showLoading(message) {
            const statusSection = document.getElementById('statusSection');
            statusSection.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>${message}</p>
                </div>
            `;
        }
        
        function generateSchedule() {
            showLoading('Generating schedule...');
            
            // Use setTimeout to allow UI to update
            setTimeout(() => {
                try {
                    const judges = readJudgeData();
                    const classData = readClassData();
                    const trialDates = getTrialDates();
                    
                    console.log('Judges:', judges);
                    console.log('Classes:', classData);
                    console.log('Dates:', trialDates);
                    
                    const schedule = createSchedule(judges, classData, trialDates);
                    
                    scheduleResult = {
                        schedule,
                        judges,
                        classData,
                        trialDates
                    };
                    
                    displayResults();
                    showStatus('Schedule generated successfully!', 'success');
                    document.getElementById('exportBtn').style.display = 'inline-block';
                    
                } catch (error) {
                    showStatus(`Error generating schedule: ${error.message}`, 'error');
                    console.error(error);
                }
            }, 100);
        }
        
        function readJudgeData() {
            const formSheet = workbookData.Sheets['Form Responses 1'];
            const judgesSheet = workbookData.Sheets['Judges'];
            
            const formData = XLSX.utils.sheet_to_json(formSheet);
            const judgesData = XLSX.utils.sheet_to_json(judgesSheet, {header: 1});
            
            const judges = [];
            const judgeNames = judgesData[0];
            
            for (let col = 0; col < judgeNames.length; col++) {
                const judgeName = judgeNames[col];
                if (!judgeName) continue;
                
                const certifications = [];
                for (let row = 1; row < judgesData.length; row++) {
                    const className = judgesData[row][col];
                    if (className && String(className).trim()) {
                        certifications.push(String(className).trim());
                    }
                }
                
                let availableDates = [];
                let pursuing = [];
                
                const formRow = formData.find(row => row['Form Responder'] === judgeName);
                if (formRow) {
                    const datesCol = 'Which days are you available to judge on? ';
                    const pursuingCol = 'Are you currently working on any specific classes that would make you unavailable to judge?';
                    
                    // Handle dates
                    const datesValue = formRow[datesCol];
                    if (datesValue !== null && datesValue !== undefined && String(datesValue).trim() !== '' && String(datesValue) !== 'NaN') {
                        try {
                            availableDates = String(datesValue).split(',').map(d => d.trim()).filter(d => d);
                        } catch (e) {
                            console.warn(`Error parsing dates for ${judgeName}:`, e);
                            availableDates = [];
                        }
                    }
                    
                    // Handle pursuing
                    const pursuingValue = formRow[pursuingCol];
                    if (pursuingValue !== null && pursuingValue !== undefined && String(pursuingValue).trim() !== '' && String(pursuingValue) !== 'NaN') {
                        try {
                            pursuing = String(pursuingValue).split(',').map(p => p.trim()).filter(p => p);
                        } catch (e) {
                            console.warn(`Error parsing pursuing for ${judgeName}:`, e);
                            pursuing = [];
                        }
                    }
                }
                
                judges.push({
                    name: judgeName,
                    certifications,
                    availableDates,
                    pursuing,
                    pursuingViolations: {},
                    totalRoundsAssigned: 0
                });
                
                console.log(`Judge created: ${judgeName}, Available: ${availableDates.length} days, Pursuing: ${pursuing.length} classes, Certs: ${certifications.length}`);
            }
            
            console.log(`\nTotal judges created: ${judges.length}`);
            return judges;
        }
        
        function readClassData() {
            const sheet = workbookData.Sheets['class and rounds'];
            const data = XLSX.utils.sheet_to_json(sheet);
            
            const classData = {};
            
            data.forEach(row => {
                const className = row['Classes for the League'];
                const rounds = row['# of Rounds throughout the league'];
                const timeUnit = row['Time Unit'];
                
                if (className && rounds) {
                    classData[className] = {
                        rounds: parseInt(rounds),
                        timeUnit: timeUnit ? parseInt(timeUnit) : 1
                    };
                }
            });
            
            return classData;
        }
        
        function getTrialDates() {
            const sheet = workbookData.Sheets['Form Responses 1'];
            const data = XLSX.utils.sheet_to_json(sheet);
            
            const datesSet = new Set();
            const datesCol = 'Which days are you available to judge on? ';
            
            data.forEach(row => {
                if (row[datesCol]) {
                    const dates = String(row[datesCol]).split(',').map(d => d.trim());
                    dates.forEach(date => datesSet.add(date));
                }
            });
            
            return Array.from(datesSet).sort((a, b) => new Date(a) - new Date(b));
        }
        
        // Scheduling algorithm (continuing in next part...)
        function createSchedule(judges, classData, trialDates) {
            const schedule = {};
            
            // Initialize schedule structure
            for (const date of trialDates) {
                schedule[date] = {
                    ring1: [],
                    ring2: [],
                    ring3: [],
                    judgeRingAssignments: {},
                    ringTimes: { 1: 0, 2: 0, 3: 0 }
                };
            }
            
            // Step 1: Ring 1 - Fixed schedule
            for (const date of trialDates) {
                for (const className of CONFIG.HIGH_LEVEL) {
                    if (!classData[className]) continue;
                    
                    schedule[date].ring1.push({
                        class: className,
                        round: 1,
                        judge: null
                    });
                    
                    schedule[date].ringTimes[1] += classData[className].timeUnit;
                }
            }
            
            // Step 2: Distribute Ring 2 only classes
            distributeClasses(CONFIG.RING2_ONLY, 2, classData, schedule, trialDates);
            
            // Step 3: Distribute Ring 3 only classes
            distributeClasses(CONFIG.RING3_ONLY, 3, classData, schedule, trialDates);
            
            // Step 4: Distribute flexible classes
            distributeFlexibleClasses(CONFIG.FLEXIBLE_CLASSES, classData, schedule, trialDates);
            
            // Step 5: Assign judges
            assignJudges(schedule, judges, trialDates);
            
            // Step 6: Optimize to reduce pursuing violations
            optimizePursuingViolations(schedule, judges, trialDates, classData);
            
            return schedule;
        }
        
        function distributeClasses(classList, targetRing, classData, schedule, trialDates) {
            const MAX_CLASSES_PER_RING_PER_DAY = 3;
            const assignments = [];
            
            for (const className of classList) {
                if (!classData[className]) continue;
                
                const totalRounds = classData[className].rounds;
                const roundsPerDay = CONFIG.ROUNDS_PER_DAY[className] || CONFIG.ROUNDS_PER_DAY.default;
                const timeUnit = classData[className].timeUnit;
                
                const daysNeeded = Math.ceil(totalRounds / roundsPerDay);
                
                for (let day = 0; day < daysNeeded; day++) {
                    const roundsThisDay = Math.min(totalRounds - (day * roundsPerDay), roundsPerDay);
                    
                    assignments.push({
                        className,
                        rounds: roundsThisDay,
                        timeUnits: roundsThisDay * timeUnit
                    });
                }
            }
            
            assignments.sort((a, b) => b.timeUnits - a.timeUnits);
            
            for (const assignment of assignments) {
                const eligibleDates = trialDates.filter(date => {
                    const alreadyScheduledInAnyRing = 
                        schedule[date].ring1.some(item => item.class === assignment.className) ||
                        schedule[date].ring2.some(item => item.class === assignment.className) ||
                        schedule[date].ring3.some(item => item.class === assignment.className);
                    
                    if (alreadyScheduledInAnyRing) return false;
                    
                    const ringKey = `ring${targetRing}`;
                    const uniqueClasses = new Set(schedule[date][ringKey].map(item => item.class));
                    if (uniqueClasses.size >= MAX_CLASSES_PER_RING_PER_DAY) return false;
                    
                    return true;
                });
                
                if (eligibleDates.length === 0) continue;
                
                const datesByLoad = eligibleDates.map(date => ({
                    date,
                    load: schedule[date].ringTimes[targetRing]
                })).sort((a, b) => a.load - b.load);
                
                const selectedDate = datesByLoad[0].date;
                const ringKey = `ring${targetRing}`;
                
                for (let round = 1; round <= assignment.rounds; round++) {
                    schedule[selectedDate][ringKey].push({
                        class: assignment.className,
                        round: round,
                        judge: null
                    });
                }
                
                schedule[selectedDate].ringTimes[targetRing] += assignment.timeUnits;
            }
        }
        
        function distributeFlexibleClasses(classList, classData, schedule, trialDates) {
            const MAX_CLASSES_PER_RING_PER_DAY = 3;
            const assignments = [];
            
            for (const className of classList) {
                if (!classData[className]) continue;
                
                const totalRounds = classData[className].rounds;
                const roundsPerDay = CONFIG.ROUNDS_PER_DAY[className] || CONFIG.ROUNDS_PER_DAY.default;
                const timeUnit = classData[className].timeUnit;
                
                const daysNeeded = Math.ceil(totalRounds / roundsPerDay);
                
                for (let day = 0; day < daysNeeded; day++) {
                    const roundsThisDay = Math.min(totalRounds - (day * roundsPerDay), roundsPerDay);
                    
                    assignments.push({
                        className,
                        rounds: roundsThisDay,
                        timeUnits: roundsThisDay * timeUnit
                    });
                }
            }
            
            assignments.sort((a, b) => b.timeUnits - a.timeUnits);
            
            for (const assignment of assignments) {
                const eligibleDatesRing2 = trialDates.filter(date => {
                    const alreadyScheduledInAnyRing = 
                        schedule[date].ring1.some(item => item.class === assignment.className) ||
                        schedule[date].ring2.some(item => item.class === assignment.className) ||
                        schedule[date].ring3.some(item => item.class === assignment.className);
                    
                    if (alreadyScheduledInAnyRing) return false;
                    
                    const uniqueClasses = new Set(schedule[date].ring2.map(item => item.class));
                    return uniqueClasses.size < MAX_CLASSES_PER_RING_PER_DAY;
                });
                
                const eligibleDatesRing3 = trialDates.filter(date => {
                    const alreadyScheduledInAnyRing = 
                        schedule[date].ring1.some(item => item.class === assignment.className) ||
                        schedule[date].ring2.some(item => item.class === assignment.className) ||
                        schedule[date].ring3.some(item => item.class === assignment.className);
                    
                    if (alreadyScheduledInAnyRing) return false;
                    
                    const uniqueClasses = new Set(schedule[date].ring3.map(item => item.class));
                    return uniqueClasses.size < MAX_CLASSES_PER_RING_PER_DAY;
                });
                
                let selectedRing = null;
                let selectedDate = null;
                
                if (eligibleDatesRing2.length > 0 && eligibleDatesRing3.length > 0) {
                    const ring2Loads = eligibleDatesRing2.map(d => ({ date: d, load: schedule[d].ringTimes[2] }));
                    const ring3Loads = eligibleDatesRing3.map(d => ({ date: d, load: schedule[d].ringTimes[3] }));
                    
                    ring2Loads.sort((a, b) => a.load - b.load);
                    ring3Loads.sort((a, b) => a.load - b.load);
                    
                    if (ring2Loads[0].load <= ring3Loads[0].load) {
                        selectedRing = 2;
                        selectedDate = ring2Loads[0].date;
                    } else {
                        selectedRing = 3;
                        selectedDate = ring3Loads[0].date;
                    }
                } else if (eligibleDatesRing2.length > 0) {
                    selectedRing = 2;
                    const loads = eligibleDatesRing2.map(d => ({ date: d, load: schedule[d].ringTimes[2] }));
                    loads.sort((a, b) => a.load - b.load);
                    selectedDate = loads[0].date;
                } else if (eligibleDatesRing3.length > 0) {
                    selectedRing = 3;
                    const loads = eligibleDatesRing3.map(d => ({ date: d, load: schedule[d].ringTimes[3] }));
                    loads.sort((a, b) => a.load - b.load);
                    selectedDate = loads[0].date;
                }
                
                if (selectedRing && selectedDate) {
                    const ringKey = `ring${selectedRing}`;
                    for (let round = 1; round <= assignment.rounds; round++) {
                        schedule[selectedDate][ringKey].push({
                            class: assignment.className,
                            round: round,
                            judge: null
                        });
                    }
                    
                    schedule[selectedDate].ringTimes[selectedRing] += assignment.timeUnits;
                }
            }
        }
        
        function assignJudges(schedule, judges, trialDates) {
            console.log('\n=== ASSIGNING JUDGES ===');
            
            // Track days worked per judge
            const judgeDaysWorked = {};
            for (const judge of judges) {
                judgeDaysWorked[judge.name] = 0;
            }
            
            for (const date of trialDates) {
                console.log(`\n${date}:`);
                const daySchedule = schedule[date];
                
                // Get all judges available on this date
                const availableJudges = judges.filter(j => j.availableDates.includes(date));
                console.log(`  Available judges: ${availableJudges.map(j => j.name).join(', ')}`);
                
                // Sort by LIMITED AVAILABILITY (fewest total days available = highest priority)
                availableJudges.sort((a, b) => {
                    // Priority 1: Fewest TOTAL available days (use limited judges first!)
                    if (a.availableDates.length !== b.availableDates.length) {
                        return a.availableDates.length - b.availableDates.length;
                    }
                    
                    // Priority 2: Fewest days already worked (balance within same availability tier)
                    const aDaysWorked = judgeDaysWorked[a.name] || 0;
                    const bDaysWorked = judgeDaysWorked[b.name] || 0;
                    if (aDaysWorked !== bDaysWorked) {
                        return aDaysWorked - bDaysWorked;
                    }
                    
                    // Priority 3: Alphabetical (stable, consistent tie-breaker)
                    return a.name.localeCompare(b.name);
                });
                
                console.log(`  Sorted order (by availability):`);
                for (const j of availableJudges) {
                    const daysWorked = judgeDaysWorked[j.name] || 0;
                    console.log(`    ${j.name}: ${j.availableDates.length} days available, ${daysWorked} days worked so far`);
                }
                
                const judgeRingAssignments = {};
                
                // Assign Ring 1 (high-level)
                const ring1Judge = findBestJudgeForRing(
                    availableJudges, daySchedule.ring1, judgeRingAssignments, 'Ring 1'
                );
                if (ring1Judge) {
                    for (const item of daySchedule.ring1) {
                        item.judge = ring1Judge.name;
                    }
                    judgeRingAssignments[ring1Judge.name] = 1;
                    daySchedule.judgeRingAssignments[ring1Judge.name] = 1;
                    ring1Judge.totalRoundsAssigned += daySchedule.ring1.length;
                    judgeDaysWorked[ring1Judge.name]++;
                    console.log(`  Ring 1: ${ring1Judge.name} (${ring1Judge.availableDates.length} days avail)`);
                }
                
                // Assign Ring 2
                const ring2Judge = findBestJudgeForRing(
                    availableJudges, daySchedule.ring2, judgeRingAssignments, 'Ring 2'
                );
                if (ring2Judge) {
                    for (const item of daySchedule.ring2) {
                        item.judge = ring2Judge.name;
                    }
                    judgeRingAssignments[ring2Judge.name] = 2;
                    daySchedule.judgeRingAssignments[ring2Judge.name] = 2;
                    ring2Judge.totalRoundsAssigned += daySchedule.ring2.length;
                    judgeDaysWorked[ring2Judge.name]++;
                    console.log(`  Ring 2: ${ring2Judge.name} (${ring2Judge.availableDates.length} days avail)`);
                }
                
                // Assign Ring 3
                const ring3Judge = findBestJudgeForRing(
                    availableJudges, daySchedule.ring3, judgeRingAssignments, 'Ring 3'
                );
                if (ring3Judge) {
                    for (const item of daySchedule.ring3) {
                        item.judge = ring3Judge.name;
                    }
                    judgeRingAssignments[ring3Judge.name] = 3;
                    daySchedule.judgeRingAssignments[ring3Judge.name] = 3;
                    ring3Judge.totalRoundsAssigned += daySchedule.ring3.length;
                    judgeDaysWorked[ring3Judge.name]++;
                    console.log(`  Ring 3: ${ring3Judge.name} (${ring3Judge.availableDates.length} days avail)`);
                }
            }
            
            // Log final balance
            console.log('\n=== JUDGE WORKLOAD BALANCE ===');
            const sortedJudges = Object.entries(judgeDaysWorked)
                .filter(([name, days]) => days > 0)
                .sort((a, b) => b[1] - a[1]);
            
            for (const [name, days] of sortedJudges) {
                const judge = judges.find(j => j.name === name);
                const avail = judge.availableDates.length;
                const util = (days / avail * 100).toFixed(0);
                console.log(`${name}: ${days}/${avail} days (${util}% util), ${judge.totalRoundsAssigned} rounds`);
            }
        }
        
        function findBestJudgeForRing(availableJudges, ringClasses, judgeRingAssignments, ringName) {
            if (ringClasses.length === 0) return null;
            
            const classNames = [...new Set(ringClasses.map(item => item.class))];
            console.log(`    ${ringName} needs: ${classNames.join(', ')}`);
            
            // Pass 1: Non-pursuing judges only
            for (const judge of availableJudges) {
                // Already assigned a ring today?
                if (judgeRingAssignments[judge.name]) {
                    console.log(`      ${judge.name}: ‚ùå Already assigned to Ring ${judgeRingAssignments[judge.name]}`);
                    continue;
                }
                
                // Certified for all classes?
                const certifiedForAll = classNames.every(c => judge.certifications.includes(c));
                if (!certifiedForAll) {
                    const missing = classNames.filter(c => !judge.certifications.includes(c));
                    console.log(`      ${judge.name}: ‚ùå Not certified for ${missing.join(', ')}`);
                    continue;
                }
                
                // NOT pursuing any classes?
                const pursuing = judge.pursuing || [];
                const pursuingAny = classNames.some(c => pursuing.includes(c));
                if (pursuingAny) {
                    const pursuingWhich = classNames.filter(c => pursuing.includes(c));
                    
                    // SPECIAL CASE: If judge has ‚â§2 days availability, allow pursuing to maximize utilization
                    if (judge.availableDates.length <= 2) {
                        console.log(`      ${judge.name}: ‚ö†Ô∏è Pursuing ${pursuingWhich.join(', ')} BUT LIMITED AVAILABILITY - ALLOWING`);
                        
                        // Track violations
                        for (const c of pursuingWhich) {
                            judge.pursuingViolations[c] = (judge.pursuingViolations[c] || 0) + 1;
                        }
                        
                        return judge;
                    } else {
                        console.log(`      ${judge.name}: ‚ö†Ô∏è Pursuing ${pursuingWhich.join(', ')} (will try pass 2)`);
                        continue;
                    }
                }
                
                // Found a perfect match!
                console.log(`      ${judge.name}: ‚úÖ SELECTED (Pass 1)`);
                return judge;
            }
            
            // Pass 2: Pursuing judges (with limit) - for flexible judges only
            console.log(`    Pass 2: Looking for pursuing judges...`);
            for (const judge of availableJudges) {
                if (judgeRingAssignments[judge.name]) continue;
                
                const certifiedForAll = classNames.every(c => judge.certifications.includes(c));
                if (!certifiedForAll) continue;
                
                const pursuing = judge.pursuing || [];
                const pursuingClasses = classNames.filter(c => pursuing.includes(c));
                if (pursuingClasses.length === 0) continue; // Already handled in pass 1
                
                // Check pursuing violation limit
                const underLimit = pursuingClasses.every(c => {
                    const count = judge.pursuingViolations[c] || 0;
                    return count < CONFIG.MAX_PURSUING_VIOLATIONS;
                });
                
                if (!underLimit) {
                    console.log(`      ${judge.name}: ‚ùå Over pursuing limit`);
                    continue;
                }
                
                // Track violations
                for (const c of pursuingClasses) {
                    judge.pursuingViolations[c] = (judge.pursuingViolations[c] || 0) + 1;
                }
                
                console.log(`      ${judge.name}: ‚úÖ SELECTED (Pass 2 - pursuing violation)`);
                return judge;
            }
            
            console.log(`      ‚ùå NO JUDGE FOUND`);
            return null;
        }
        
        // Optimize pursuing violations by swapping classes between days
        function optimizePursuingViolations(schedule, judges, trialDates, classData) {
            console.log('\n=== OPTIMIZING PURSUING VIOLATIONS ===');
            
            // Debug: Check all judges have proper pursuing arrays
            console.log('Checking judge data integrity:');
            for (const judge of judges) {
                if (!judge.pursuing || !Array.isArray(judge.pursuing)) {
                    console.warn(`‚ö†Ô∏è ${judge.name}: pursuing is ${judge.pursuing}, fixing to []`);
                    judge.pursuing = [];
                }
                if (judge.pursuing.length > 0) {
                    console.log(`  ${judge.name}: pursuing ${judge.pursuing.length} classes - ${judge.pursuing.join(', ')}`);
                }
            }
            
            let totalSwapsMade = 0;
            const initialViolations = countPursuingViolations(schedule, judges, trialDates);
            console.log(`Initial pursuing violations: ${initialViolations}`);
            
            if (initialViolations === 0) {
                console.log('‚úÖ No pursuing violations to optimize!');
                return;
            }
            
            // Multiple optimization passes
            const MAX_PASSES = 5;
            let currentPass = 0;
            let previousViolations = initialViolations;
            
            while (currentPass < MAX_PASSES) {
                currentPass++;
                console.log(`\n--- Optimization Pass ${currentPass} ---`);
                
                let swapsThisPass = 0;
                
                // STRATEGY 1: Swap judges between dates for same ring
                swapsThisPass += swapJudgesBetweenDates(schedule, judges, trialDates);
                
                // STRATEGY 2: Swap rings between judges on same date
                swapsThisPass += swapRingsBetweenJudges(schedule, judges, trialDates);
                
                // STRATEGY 3: Swap individual classes between dates (NEW!)
                swapsThisPass += swapClassesBetweenDates(schedule, judges, trialDates, classData);
                
                const currentViolations = countPursuingViolations(schedule, judges, trialDates);
                console.log(`Pass ${currentPass} result: ${swapsThisPass} swaps, ${previousViolations} ‚Üí ${currentViolations} violations`);
                
                totalSwapsMade += swapsThisPass;
                
                // If no improvement, stop
                if (swapsThisPass === 0 || currentViolations === 0) {
                    break;
                }
                
                previousViolations = currentViolations;
            }
            
            const finalViolations = countPursuingViolations(schedule, judges, trialDates);
            console.log(`\n=== OPTIMIZATION COMPLETE ===`);
            console.log(`Total swaps: ${totalSwapsMade}`);
            console.log(`Pursuing violations: ${initialViolations} ‚Üí ${finalViolations}`);
            
            if (finalViolations > 0) {
                console.log(`‚ö†Ô∏è ${finalViolations} pursuing violations remain`);
                logRemainingViolations(schedule, judges, trialDates);
            } else {
                console.log(`‚úÖ ALL PURSUING VIOLATIONS ELIMINATED!`);
            }
        }
        
        // STRATEGY 3: Swap individual classes between dates to help limited-availability judges
        function swapClassesBetweenDates(schedule, judges, trialDates, classData) {
            let swapsMade = 0;
            
            console.log('  Strategy 3: Swapping individual classes...');
            
            // Focus on limited-availability judges (‚â§2 days) with pursuing violations
            const limitedJudges = judges.filter(j => j.availableDates.length <= 2);
            
            for (const judge of limitedJudges) {
                // Find dates where this judge is working
                const workingDates = [];
                for (const date of trialDates) {
                    for (let ring = 1; ring <= 3; ring++) {
                        const ringKey = `ring${ring}`;
                        const ringItems = schedule[date][ringKey];
                        if (ringItems.length > 0 && ringItems[0].judge === judge.name) {
                            workingDates.push({ date, ring, ringKey, ringItems });
                            break;
                        }
                    }
                }
                
                // For each date this judge works, check for pursuing violations
                for (const { date, ring, ringKey, ringItems } of workingDates) {
                    const classes = [...new Set(ringItems.map(item => item.class))];
                    const pursuing = judge.pursuing || [];
                    const pursuingClasses = classes.filter(c => pursuing.includes(c));
                    
                    if (pursuingClasses.length === 0) continue; // No violations here
                    
                    console.log(`    ${judge.name} on ${date} Ring ${ring}: pursuing ${pursuingClasses.join(', ')}`);
                    
                    // Try to swap each pursuing class with a non-pursuing class from another date
                    for (const pursuingClass of pursuingClasses) {
                        // Find where else this pursuing class appears (with different judge)
                        for (const otherDate of trialDates) {
                            if (otherDate === date) continue;
                            
                            for (let otherRing = 1; otherRing <= 3; otherRing++) {
                                const otherRingKey = `ring${otherRing}`;
                                const otherRingItems = schedule[otherDate][otherRingKey];
                                
                                if (otherRingItems.length === 0) continue;
                                
                                const otherJudgeName = otherRingItems[0].judge;
                                if (otherJudgeName === judge.name) continue; // Same judge
                                
                                const otherJudge = judges.find(j => j.name === otherJudgeName);
                                if (!otherJudge) continue;
                                
                                const otherClasses = [...new Set(otherRingItems.map(item => item.class))];
                                
                                // Does this ring have a class that judge is NOT pursuing?
                                const otherPursuing = otherJudge.pursuing || [];
                                const nonPursuingClasses = otherClasses.filter(c => !pursuing.includes(c));
                                
                                if (nonPursuingClasses.length === 0) continue;
                                
                                // Try swapping pursuing class with each non-pursuing class
                                for (const swapClass of nonPursuingClasses) {
                                    // Validate swap
                                    const canSwap = validateClassSwap(
                                        schedule, judge, otherJudge, 
                                        date, ring, pursuingClass,
                                        otherDate, otherRing, swapClass,
                                        classData
                                    );
                                    
                                    if (canSwap) {
                                        // Perform the swap
                                        performClassSwap(
                                            schedule, 
                                            date, ringKey, pursuingClass,
                                            otherDate, otherRingKey, swapClass
                                        );
                                        
                                        console.log(`      ‚úì SWAP: ${pursuingClass} (${date} Ring ${ring}) ‚Üî ${swapClass} (${otherDate} Ring ${otherRing})`);
                                        swapsMade++;
                                        
                                        // Move to next pursuing class
                                        break;
                                    }
                                }
                                
                                if (swapsMade > 0) break; // Found a swap, move on
                            }
                            
                            if (swapsMade > 0) break;
                        }
                    }
                }
            }
            
            return swapsMade;
        }
        
        // Validate if a class swap is legal
        function validateClassSwap(schedule, judge1, judge2, date1, ring1, class1, date2, ring2, class2, classData) {
            // Check 1: Judge 1 can handle class 2
            if (!judge1.certifications.includes(class2)) return false;
            
            // Check 2: Judge 2 can handle class 1
            if (!judge2.certifications.includes(class1)) return false;
            
            // Check 3: Judge 2 available on date1
            if (!judge2.availableDates.includes(date1)) return false;
            
            // Check 4: Judge 1 available on date2
            if (!judge1.availableDates.includes(date2)) return false;
            
            // Check 5: No duplicate class on same day across rings (after swap)
            const ring1Key = `ring${ring1}`;
            const ring2Key = `ring${ring2}`;
            
            // After swap, date1 will have class2 in ring1
            for (let r = 1; r <= 3; r++) {
                if (r === ring1) continue;
                const rKey = `ring${r}`;
                const classes = schedule[date1][rKey].map(item => item.class);
                if (classes.includes(class2)) return false; // Would create duplicate
            }
            
            // After swap, date2 will have class1 in ring2
            for (let r = 1; r <= 3; r++) {
                if (r === ring2) continue;
                const rKey = `ring${r}`;
                const classes = schedule[date2][rKey].map(item => item.class);
                if (classes.includes(class1)) return false; // Would create duplicate
            }
            
            // Check 6: Ring compatibility (Ring 1 classes must stay in Ring 1, etc.)
            const ring1Classes = CONFIG.RING_1_CLASSES;
            const ring2OnlyClasses = CONFIG.RING_2_ONLY_CLASSES;
            const ring3OnlyClasses = CONFIG.RING_3_ONLY_CLASSES;
            
            // If class1 is Ring 1 only, can't move it
            if (ring1Classes.includes(class1) && ring1 === 1 && ring2 !== 1) return false;
            
            // If class2 is Ring 1 only, can't move it
            if (ring1Classes.includes(class2) && ring2 === 1 && ring1 !== 1) return false;
            
            // If class1 is Ring 2 only, must stay in Ring 2
            if (ring2OnlyClasses.includes(class1) && ring2 !== 2) return false;
            
            // If class2 is Ring 2 only, must stay in Ring 2
            if (ring2OnlyClasses.includes(class2) && ring1 !== 2) return false;
            
            // If class1 is Ring 3 only, must stay in Ring 3
            if (ring3OnlyClasses.includes(class1) && ring2 !== 3) return false;
            
            // If class2 is Ring 3 only, must stay in Ring 3
            if (ring3OnlyClasses.includes(class2) && ring1 !== 3) return false;
            
            return true;
        }
        
        // Perform the actual class swap
        function performClassSwap(schedule, date1, ring1Key, class1, date2, ring2Key, class2) {
            // Swap all rounds of class1 on date1/ring1 with all rounds of class2 on date2/ring2
            const ring1Items = schedule[date1][ring1Key];
            const ring2Items = schedule[date2][ring2Key];
            
            // Replace class1 with class2 on date1
            for (const item of ring1Items) {
                if (item.class === class1) {
                    item.class = class2;
                }
            }
            
            // Replace class2 with class1 on date2
            for (const item of ring2Items) {
                if (item.class === class2) {
                    item.class = class1;
                }
            }
        }
        
        // STRATEGY 1: Swap judge assignments between dates for the same ring
        function swapJudgesBetweenDates(schedule, judges, trialDates) {
            let swapsMade = 0;
            
            for (let ring = 1; ring <= 3; ring++) {
                const ringKey = `ring${ring}`;
                
                for (let i = 0; i < trialDates.length; i++) {
                    const date1 = trialDates[i];
                    const day1 = schedule[date1];
                    
                    if (day1[ringKey].length === 0) continue;
                    const judge1 = day1[ringKey][0].judge;
                    if (!judge1) continue;
                    
                    const judge1Obj = judges.find(j => j.name === judge1);
                    if (!judge1Obj) continue;
                    
                    const classesOnDate1 = [...new Set(day1[ringKey].map(item => item.class))];
                    const pursuing1 = judge1Obj.pursuing || [];
                    const pursuingOnDate1 = classesOnDate1.filter(c => pursuing1.includes(c));
                    
                    if (pursuingOnDate1.length === 0) continue;
                    
                    // Try swapping with other dates
                    for (let j = 0; j < trialDates.length; j++) {
                        if (i === j) continue;
                        
                        const date2 = trialDates[j];
                        const day2 = schedule[date2];
                        
                        if (day2[ringKey].length === 0) continue;
                        const judge2 = day2[ringKey][0].judge;
                        if (!judge2 || judge2 === judge1) continue;
                        
                        const judge2Obj = judges.find(j => j.name === judge2);
                        if (!judge2Obj) continue;
                        
                        const classesOnDate2 = [...new Set(day2[ringKey].map(item => item.class))];
                        const pursuing2 = judge2Obj.pursuing || [];
                        const pursuingOnDate2 = classesOnDate2.filter(c => pursuing2.includes(c));
                        
                        // Check if swap would improve things
                        const date1PursuingAfter = classesOnDate1.filter(c => pursuing2.includes(c));
                        const date2PursuingAfter = classesOnDate2.filter(c => pursuing1.includes(c));
                        const violationsBefore = pursuingOnDate1.length + pursuingOnDate2.length;
                        const violationsAfter = date1PursuingAfter.length + date2PursuingAfter.length;
                        
                        if (violationsAfter >= violationsBefore) continue; // No improvement
                        
                        // Check if swap is valid
                        const judge2CanHandleDate1 = classesOnDate1.every(c => 
                            judge2Obj.certifications.includes(c) &&
                            judge2Obj.availableDates.includes(date1)
                        );
                        
                        const judge1CanHandleDate2 = classesOnDate2.every(c => 
                            judge1Obj.certifications.includes(c) &&
                            judge1Obj.availableDates.includes(date2)
                        );
                        
                        if (judge2CanHandleDate1 && judge1CanHandleDate2) {
                            console.log(`  ‚úì SWAP Ring ${ring}: ${judge1} (${date1}) ‚Üî ${judge2} (${date2}) | Violations ${violationsBefore} ‚Üí ${violationsAfter}`);
                            
                            // Perform swap
                            for (const item of day1[ringKey]) {
                                item.judge = judge2;
                            }
                            for (const item of day2[ringKey]) {
                                item.judge = judge1;
                            }
                            
                            delete day1.judgeRingAssignments[judge1];
                            delete day2.judgeRingAssignments[judge2];
                            day1.judgeRingAssignments[judge2] = ring;
                            day2.judgeRingAssignments[judge1] = ring;
                            
                            swapsMade++;
                            break;
                        }
                    }
                }
            }
            
            return swapsMade;
        }
        
        // STRATEGY 2: Swap ring assignments between judges on the same date
        function swapRingsBetweenJudges(schedule, judges, trialDates) {
            let swapsMade = 0;
            
            for (const date of trialDates) {
                const day = schedule[date];
                
                // Try swapping between all ring pairs
                const ringPairs = [[1, 2], [1, 3], [2, 3]];
                
                for (const [ring1, ring2] of ringPairs) {
                    const ring1Key = `ring${ring1}`;
                    const ring2Key = `ring${ring2}`;
                    
                    if (day[ring1Key].length === 0 || day[ring2Key].length === 0) continue;
                    
                    const judge1 = day[ring1Key][0].judge;
                    const judge2 = day[ring2Key][0].judge;
                    
                    if (!judge1 || !judge2 || judge1 === judge2) continue;
                    
                    const judge1Obj = judges.find(j => j.name === judge1);
                    const judge2Obj = judges.find(j => j.name === judge2);
                    
                    if (!judge1Obj || !judge2Obj) continue;
                    
                    const ring1Classes = [...new Set(day[ring1Key].map(item => item.class))];
                    const ring2Classes = [...new Set(day[ring2Key].map(item => item.class))];
                    
                    const pursuing1 = judge1Obj.pursuing || [];
                    const pursuing2 = judge2Obj.pursuing || [];
                    
                    const ring1Pursuing = ring1Classes.filter(c => pursuing1.includes(c));
                    const ring2Pursuing = ring2Classes.filter(c => pursuing2.includes(c));
                    
                    if (ring1Pursuing.length === 0 && ring2Pursuing.length === 0) continue;
                    
                    // Check if swap would improve
                    const ring1PursuingAfter = ring1Classes.filter(c => pursuing2.includes(c));
                    const ring2PursuingAfter = ring2Classes.filter(c => pursuing1.includes(c));
                    const violationsBefore = ring1Pursuing.length + ring2Pursuing.length;
                    const violationsAfter = ring1PursuingAfter.length + ring2PursuingAfter.length;
                    
                    if (violationsAfter >= violationsBefore) continue;
                    
                    // Check if swap is valid
                    const judge2CanHandleRing1 = ring1Classes.every(c => judge2Obj.certifications.includes(c));
                    const judge1CanHandleRing2 = ring2Classes.every(c => judge1Obj.certifications.includes(c));
                    
                    if (judge2CanHandleRing1 && judge1CanHandleRing2) {
                        console.log(`  ‚úì SWAP ${date}: Ring ${ring1} ${judge1} ‚Üî Ring ${ring2} ${judge2} | Violations ${violationsBefore} ‚Üí ${violationsAfter}`);
                        
                        // Perform swap
                        for (const item of day[ring1Key]) {
                            item.judge = judge2;
                        }
                        for (const item of day[ring2Key]) {
                            item.judge = judge1;
                        }
                        
                        day.judgeRingAssignments[judge1] = ring2;
                        day.judgeRingAssignments[judge2] = ring1;
                        
                        swapsMade++;
                    }
                }
            }
            
            return swapsMade;
        }
        
        function logRemainingViolations(schedule, judges, trialDates) {
            console.log('\nRemaining violations:');
            
            for (const date of trialDates) {
                for (let ring = 1; ring <= 3; ring++) {
                    const ringKey = `ring${ring}`;
                    const ringItems = schedule[date][ringKey];
                    
                    if (ringItems.length === 0) continue;
                    
                    const judgeName = ringItems[0].judge;
                    if (!judgeName) continue;
                    
                    const judge = judges.find(j => j.name === judgeName);
                    if (!judge) continue;
                    
                    const classes = [...new Set(ringItems.map(item => item.class))];
                    const pursuing = judge.pursuing || [];
                    const pursuingClasses = classes.filter(c => pursuing.includes(c));
                    
                    if (pursuingClasses.length > 0) {
                        console.log(`  ${date} Ring ${ring}: ${judgeName} pursuing ${pursuingClasses.join(', ')}`);
                    }
                }
            }
        }
        
        function countPursuingViolations(schedule, judges, trialDates) {
            let violations = 0;
            
            for (const date of trialDates) {
                for (let ring = 1; ring <= 3; ring++) {
                    const ringKey = `ring${ring}`;
                    const ringItems = schedule[date][ringKey];
                    
                    if (ringItems.length === 0) continue;
                    
                    const judgeName = ringItems[0].judge;
                    if (!judgeName) continue;
                    
                    const judge = judges.find(j => j.name === judgeName);
                    if (!judge) continue;
                    
                    const classes = [...new Set(ringItems.map(item => item.class))];
                    const pursuing = judge.pursuing || [];
                    const pursuingClasses = classes.filter(c => pursuing.includes(c));
                    
                    violations += pursuingClasses.length;
                }
            }
            
            return violations;
        }
        
        // Display functions
        function displayResults() {
            displaySchedule();
            displayGrid();
            displaySummary();
            document.getElementById('resultsSection').style.display = 'block';
        }
        
        function displaySchedule() {
            const { schedule, trialDates, judges } = scheduleResult;
            const container = document.getElementById('scheduleTab');
            
            let html = '<h2>Trial Schedule (Editable)</h2>';
            html += '<p style="margin-bottom: 20px; color: #555;">üí° <strong>Drag classes to swap</strong> (judges stay in their positions). Drag near screen edges to <strong>auto-scroll</strong>. Works on <strong>mobile</strong> too! <strong>Change judges</strong> using dropdowns. Green = valid. Grey = invalid.</p>';
            
            // Get all judge names for dropdowns
            const judgeNames = judges.map(j => j.name).sort();
            
            for (const date of trialDates) {
                const daySchedule = schedule[date];
                
                html += `<div class="date-header">${date}</div>`;
                html += '<table>';
                html += '<tr><th>Ring 1 - K9 Side</th><th>Judge</th><th>Ring 2 - Inside</th><th>Judge</th><th>Ring 3 - Parking Lot</th><th>Judge</th></tr>';
                
                const maxRows = Math.max(
                    daySchedule.ring1.length,
                    daySchedule.ring2.length,
                    daySchedule.ring3.length
                );
                
                for (let i = 0; i < maxRows; i++) {
                    html += '<tr>';
                    
                    // Ring 1
                    if (i < daySchedule.ring1.length) {
                        const item = daySchedule.ring1[i];
                        const isFirstRound = item.round === 1;
                        html += createDraggableClassCell(date, 'ring1', item, isFirstRound);
                        html += `<td>${createJudgeDropdown(date, 'ring1', i, item.judge, judgeNames, judges)}</td>`;
                    } else {
                        html += '<td></td><td></td>';
                    }
                    
                    // Ring 2
                    if (i < daySchedule.ring2.length) {
                        const item = daySchedule.ring2[i];
                        const isFirstRound = item.round === 1;
                        html += createDraggableClassCell(date, 'ring2', item, isFirstRound);
                        html += `<td>${createJudgeDropdown(date, 'ring2', i, item.judge, judgeNames, judges)}</td>`;
                    } else {
                        html += '<td></td><td></td>';
                    }
                    
                    // Ring 3
                    if (i < daySchedule.ring3.length) {
                        const item = daySchedule.ring3[i];
                        const isFirstRound = item.round === 1;
                        html += createDraggableClassCell(date, 'ring3', item, isFirstRound);
                        html += `<td>${createJudgeDropdown(date, 'ring3', i, item.judge, judgeNames, judges)}</td>`;
                    } else {
                        html += '<td></td><td></td>';
                    }
                    
                    html += '</tr>';
                }
                
                html += '</table>';
                html += `<p style="margin: 10px 0; font-weight: bold;">Time Units: Ring 1 = ${daySchedule.ringTimes[1]}, Ring 2 = ${daySchedule.ringTimes[2]}, Ring 3 = ${daySchedule.ringTimes[3]}</p>`;
            }
            
            container.innerHTML = html;
            
            // Add event listeners
            container.querySelectorAll('.judge-dropdown').forEach(select => {
                select.addEventListener('change', handleJudgeChange);
            });
            
            // Setup drag and drop
            setupDragAndDrop();
        }
        
        // Create draggable class cell
        function createDraggableClassCell(date, ringKey, item, isFirstRound) {
            const className = item.class;
            const round = item.round;
            
            if (isFirstRound) {
                // First round is draggable - represents the entire class
                return `<td class="draggable-class drop-zone" draggable="true" 
                    data-date="${date}" 
                    data-ring="${ringKey}" 
                    data-class="${className}">
                    <span class="drag-handle">‚ãÆ‚ãÆ</span> ${className} Round ${round}
                </td>`;
            } else {
                // Subsequent rounds are part of the draggable group
                return `<td class="non-first-round drop-zone" 
                    data-date="${date}" 
                    data-ring="${ringKey}" 
                    data-class="${className}">
                    ${className} Round ${round}
                </td>`;
            }
        }
        
        // Setup drag and drop handlers
        let autoScrollInterval = null;
        
        function setupDragAndDrop() {
            const draggables = document.querySelectorAll('.draggable-class');
            const dropZones = document.querySelectorAll('.drop-zone');
            
            draggables.forEach(element => {
                // Desktop drag events
                element.addEventListener('dragstart', handleDragStart);
                element.addEventListener('dragend', handleDragEnd);
                
                // Mobile touch events
                element.addEventListener('touchstart', handleTouchStart, { passive: false });
            });
            
            dropZones.forEach(element => {
                element.addEventListener('dragover', handleDragOver);
                element.addEventListener('dragenter', handleDragEnter);
                element.addEventListener('dragleave', handleDragLeave);
                element.addEventListener('drop', handleDrop);
            });
            
            // Add drag event listener to detect when near viewport edges
            document.addEventListener('drag', handleDrag);
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);
        }
        
        let draggedElement = null;
        let draggedData = null;
        let touchDragElement = null;
        let touchStartY = 0;
        let touchStartX = 0;
        
        function handleDrag(e) {
            if (!draggedData) return;
            
            // Auto-scroll when near viewport edges
            const SCROLL_ZONE = 100; // pixels from edge
            const SCROLL_SPEED = 10; // pixels per frame
            
            const viewportHeight = window.innerHeight;
            const mouseY = e.clientY;
            
            // Clear any existing scroll interval
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }
            
            // Remove scroll indicators
            document.body.classList.remove('auto-scrolling-up', 'auto-scrolling-down');
            
            // Scroll down when near bottom
            if (mouseY > viewportHeight - SCROLL_ZONE && mouseY > 0) {
                document.body.classList.add('auto-scrolling-down');
                autoScrollInterval = setInterval(() => {
                    window.scrollBy(0, SCROLL_SPEED);
                }, 16); // ~60fps
            }
            // Scroll up when near top
            else if (mouseY < SCROLL_ZONE && mouseY > 0) {
                document.body.classList.add('auto-scrolling-up');
                autoScrollInterval = setInterval(() => {
                    window.scrollBy(0, -SCROLL_SPEED);
                }, 16);
            }
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            
            touchDragElement = e.target.closest('.draggable-class');
            if (!touchDragElement) return;
            
            draggedData = {
                sourceDate: touchDragElement.dataset.date,
                sourceRing: touchDragElement.dataset.ring,
                sourceClass: touchDragElement.dataset.class
            };
            
            touchDragElement.classList.add('dragging');
            
            // Highlight all rounds of this class
            const schedule = scheduleResult.schedule;
            const ringItems = schedule[draggedData.sourceDate][draggedData.sourceRing];
            
            document.querySelectorAll('.drop-zone').forEach(cell => {
                if (cell.dataset.date === draggedData.sourceDate && 
                    cell.dataset.ring === draggedData.sourceRing && 
                    cell.dataset.class === draggedData.sourceClass) {
                    cell.classList.add('dragging-group');
                }
            });
            
            // Highlight valid drop zones
            setTimeout(() => highlightValidDropZones(draggedData), 10);
            
            // Create ghost element for visual feedback
            const ghost = touchDragElement.cloneNode(true);
            ghost.id = 'touch-drag-ghost';
            ghost.style.position = 'fixed';
            ghost.style.pointerEvents = 'none';
            ghost.style.opacity = '0.8';
            ghost.style.zIndex = '10000';
            ghost.style.left = touch.clientX + 'px';
            ghost.style.top = touch.clientY + 'px';
            ghost.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(ghost);
        }
        
        function handleTouchMove(e) {
            if (!touchDragElement || !draggedData) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const ghost = document.getElementById('touch-drag-ghost');
            if (ghost) {
                ghost.style.left = touch.clientX + 'px';
                ghost.style.top = touch.clientY + 'px';
            }
            
            // Auto-scroll when near edges
            const SCROLL_ZONE = 100;
            const SCROLL_SPEED = 10;
            const viewportHeight = window.innerHeight;
            const touchY = touch.clientY;
            
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }
            
            // Remove scroll indicators
            document.body.classList.remove('auto-scrolling-up', 'auto-scrolling-down');
            
            if (touchY > viewportHeight - SCROLL_ZONE) {
                document.body.classList.add('auto-scrolling-down');
                autoScrollInterval = setInterval(() => {
                    window.scrollBy(0, SCROLL_SPEED);
                }, 16);
            } else if (touchY < SCROLL_ZONE) {
                document.body.classList.add('auto-scrolling-up');
                autoScrollInterval = setInterval(() => {
                    window.scrollBy(0, -SCROLL_SPEED);
                }, 16);
            }
            
            // Find element under touch
            ghost.style.display = 'none';
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            ghost.style.display = 'block';
            
            // Update drag-over highlighting
            document.querySelectorAll('.drop-zone').forEach(zone => {
                zone.classList.remove('drag-over');
            });
            
            const dropZone = elementBelow?.closest('.drop-zone.draggable-class');
            if (dropZone) {
                dropZone.classList.add('drag-over');
            }
        }
        
        function handleTouchEnd(e) {
            if (!touchDragElement || !draggedData) return;
            e.preventDefault();
            
            // Clean up ghost
            const ghost = document.getElementById('touch-drag-ghost');
            if (ghost) {
                ghost.remove();
            }
            
            // Clear auto-scroll
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }
            
            // Remove scroll indicators
            document.body.classList.remove('auto-scrolling-up', 'auto-scrolling-down');
            
            // Find drop target
            const touch = e.changedTouches[0];
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const dropTarget = elementBelow?.closest('.drop-zone.draggable-class');
            
            if (dropTarget) {
                const targetDate = dropTarget.dataset.date;
                const targetRing = dropTarget.dataset.ring;
                const targetClass = dropTarget.dataset.class;
                
                // Perform swap
                console.log('\n=== ATTEMPTING SWAP (TOUCH) ===');
                console.log(`Source: ${draggedData.sourceClass} on ${draggedData.sourceDate} ${draggedData.sourceRing}`);
                console.log(`Target: ${targetClass} on ${targetDate} ${targetRing}`);
                
                if (targetDate !== draggedData.sourceDate || 
                    targetRing !== draggedData.sourceRing || 
                    targetClass !== draggedData.sourceClass) {
                    
                    if (isValidClassSwap(draggedData.sourceDate, draggedData.sourceRing, draggedData.sourceClass,
                                         targetDate, targetRing, targetClass)) {
                        swapClasses(draggedData.sourceDate, draggedData.sourceRing, draggedData.sourceClass,
                                   targetDate, targetRing, targetClass);
                        
                        displaySchedule();
                        displayGrid();
                        displaySummary();
                        
                        console.log('‚úì Swap completed successfully!\n');
                    } else {
                        console.log('‚ùå Swap failed - see errors above\n');
                        alert('Cannot swap classes! Check console (F12) for details.\n\nCommon issues:\n‚Ä¢ Judge at destination not certified for incoming class\n‚Ä¢ Judge at source not certified for incoming class\n‚Ä¢ Ring constraints violated\n‚Ä¢ Class already exists on that date\n\nRemember: Only classes swap, judges stay in position!');
                    }
                }
            }
            
            // Clean up
            touchDragElement.classList.remove('dragging');
            document.querySelectorAll('.drop-zone').forEach(zone => {
                zone.classList.remove('valid-drop', 'invalid-drop', 'drag-over', 'dragging-group');
            });
            
            touchDragElement = null;
            draggedData = null;
        }
        
        function handleDragStart(e) {
            draggedElement = e.target;
            draggedData = {
                sourceDate: e.target.dataset.date,
                sourceRing: e.target.dataset.ring,
                sourceClass: e.target.dataset.class
            };
            
            e.target.classList.add('dragging');
            
            // Highlight all rounds of this class
            const schedule = scheduleResult.schedule;
            const ringItems = schedule[draggedData.sourceDate][draggedData.sourceRing];
            const classRounds = ringItems.filter(item => item.class === draggedData.sourceClass);
            
            document.querySelectorAll('.drop-zone').forEach(cell => {
                if (cell.dataset.date === draggedData.sourceDate && 
                    cell.dataset.ring === draggedData.sourceRing && 
                    cell.dataset.class === draggedData.sourceClass) {
                    cell.classList.add('dragging-group');
                }
            });
            
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.innerHTML);
            
            // Highlight valid drop zones
            setTimeout(() => highlightValidDropZones(draggedData), 10);
        }
        
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            
            // Clear auto-scroll
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }
            
            // Remove scroll indicators
            document.body.classList.remove('auto-scrolling-up', 'auto-scrolling-down');
            
            // Remove all highlighting
            document.querySelectorAll('.drop-zone').forEach(zone => {
                zone.classList.remove('valid-drop', 'invalid-drop', 'drag-over', 'dragging-group');
            });
            
            draggedElement = null;
            draggedData = null;
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            return false;
        }
        
        function handleDragEnter(e) {
            const target = e.target.closest('.drop-zone');
            if (target && target.classList.contains('draggable-class')) {
                target.classList.add('drag-over');
            }
        }
        
        function handleDragLeave(e) {
            const target = e.target.closest('.drop-zone');
            if (target) {
                target.classList.remove('drag-over');
            }
        }
        
        function handleDrop(e) {
            e.stopPropagation();
            e.preventDefault();
            
            const target = e.target.closest('.drop-zone');
            if (target) {
                target.classList.remove('drag-over');
            }
            
            if (!draggedData || !target) {
                return false;
            }
            
            const targetDate = target.dataset.date;
            const targetRing = target.dataset.ring;
            const targetClass = target.dataset.class;
            
            // Can't drop on self
            if (targetDate === draggedData.sourceDate && 
                targetRing === draggedData.sourceRing && 
                targetClass === draggedData.sourceClass) {
                return false;
            }
            
            // Validate and perform swap
            console.log('\n=== ATTEMPTING SWAP ===');
            console.log(`Source: ${draggedData.sourceClass} on ${draggedData.sourceDate} ${draggedData.sourceRing}`);
            console.log(`Target: ${targetClass} on ${targetDate} ${targetRing}`);
            
            if (isValidClassSwap(draggedData.sourceDate, draggedData.sourceRing, draggedData.sourceClass,
                                 targetDate, targetRing, targetClass)) {
                swapClasses(draggedData.sourceDate, draggedData.sourceRing, draggedData.sourceClass,
                           targetDate, targetRing, targetClass);
                
                // Refresh display
                displaySchedule();
                displayGrid();
                displaySummary();
                
                console.log('‚úì Swap completed successfully!\n');
            } else {
                console.log('‚ùå Swap failed - see errors above\n');
                alert('Cannot swap classes! Check console (F12) for details.\n\nCommon issues:\n‚Ä¢ Judge at destination not certified for incoming class\n‚Ä¢ Judge at source not certified for incoming class\n‚Ä¢ Ring constraints violated\n‚Ä¢ Class already exists on that date\n\nRemember: Only classes swap, judges stay in position!');
            }
            
            return false;
        }
        
        function highlightValidDropZones(draggedData) {
            const sourceClass = draggedData.sourceClass;
            
            // Check each draggable class cell
            document.querySelectorAll('.draggable-class').forEach(cell => {
                const targetDate = cell.dataset.date;
                const targetRing = cell.dataset.ring;
                const targetClass = cell.dataset.class;
                
                // Skip source
                if (targetDate === draggedData.sourceDate && 
                    targetRing === draggedData.sourceRing && 
                    targetClass === sourceClass) {
                    return;
                }
                
                if (isValidClassSwap(draggedData.sourceDate, draggedData.sourceRing, sourceClass,
                                    targetDate, targetRing, targetClass)) {
                    cell.classList.add('valid-drop');
                } else {
                    cell.classList.add('invalid-drop');
                }
            });
        }
        
        function isValidClassSwap(sourceDate, sourceRing, sourceClass, targetDate, targetRing, targetClass) {
            if (!targetDate || !targetRing || !targetClass) return false;
            
            const schedule = scheduleResult.schedule;
            const judges = scheduleResult.judges;
            
            // Get source class items and judge (judge will STAY in source position)
            const sourceItems = schedule[sourceDate][sourceRing].filter(item => item.class === sourceClass);
            if (sourceItems.length === 0) {
                console.log(`Invalid: No source items for ${sourceClass}`);
                return false;
            }
            const sourceJudgeName = sourceItems[0].judge;
            const sourceJudge = judges.find(j => j.name === sourceJudgeName);
            if (!sourceJudge || !sourceJudge.certifications || !sourceJudge.availableDates) {
                console.log(`Invalid: Source judge ${sourceJudgeName} missing data`);
                return false;
            }
            
            // Get target class items and judge (judge will STAY in target position)
            const targetItems = schedule[targetDate][targetRing].filter(item => item.class === targetClass);
            if (targetItems.length === 0) {
                console.log(`Invalid: No target items for ${targetClass}`);
                return false;
            }
            const targetJudgeName = targetItems[0].judge;
            const targetJudge = judges.find(j => j.name === targetJudgeName);
            if (!targetJudge || !targetJudge.certifications || !targetJudge.availableDates) {
                console.log(`Invalid: Target judge ${targetJudgeName} missing data`);
                return false;
            }
            
            // RULE 1: Ring constraints
            const ring2OnlyClasses = CONFIG.RING2_ONLY || [];
            const ring3OnlyClasses = CONFIG.RING3_ONLY || [];
            const ring1Classes = CONFIG.HIGH_LEVEL || [];
            
            const sourceRingNum = parseInt(sourceRing.replace('ring', ''));
            const targetRingNum = parseInt(targetRing.replace('ring', ''));
            
            // Check source class can go to target ring
            if (ring1Classes.includes(sourceClass) && targetRingNum !== 1) {
                console.log(`Invalid: ${sourceClass} must stay in Ring 1`);
                return false;
            }
            if (ring2OnlyClasses.includes(sourceClass) && targetRingNum !== 2) {
                console.log(`Invalid: ${sourceClass} must stay in Ring 2`);
                return false;
            }
            if (ring3OnlyClasses.includes(sourceClass) && targetRingNum !== 3) {
                console.log(`Invalid: ${sourceClass} must stay in Ring 3`);
                return false;
            }
            
            // Check target class can go to source ring
            if (ring1Classes.includes(targetClass) && sourceRingNum !== 1) {
                console.log(`Invalid: ${targetClass} must stay in Ring 1`);
                return false;
            }
            if (ring2OnlyClasses.includes(targetClass) && sourceRingNum !== 2) {
                console.log(`Invalid: ${targetClass} must stay in Ring 2`);
                return false;
            }
            if (ring3OnlyClasses.includes(targetClass) && sourceRingNum !== 3) {
                console.log(`Invalid: ${targetClass} must stay in Ring 3`);
                return false;
            }
            
            // RULE 2: Judge certifications (judges STAY where they are, so check if they can handle the NEW class)
            // Source judge stays at source position but gets target class
            if (!sourceJudge.certifications.includes(targetClass)) {
                console.log(`Invalid: ${sourceJudgeName} (stays at source) not certified for ${targetClass} (incoming class)`);
                return false;
            }
            
            // Target judge stays at target position but gets source class
            if (!targetJudge.certifications.includes(sourceClass)) {
                console.log(`Invalid: ${targetJudgeName} (stays at target) not certified for ${sourceClass} (incoming class)`);
                return false;
            }
            
            // RULE 3: No duplicate class on same date (if swapping between different dates)
            if (sourceDate !== targetDate) {
                // Check if source class already exists on target date in other rings
                for (let ring = 1; ring <= 3; ring++) {
                    const ringKey = `ring${ring}`;
                    if (ringKey === targetRing) continue;
                    const hasClass = schedule[targetDate][ringKey].some(item => item.class === sourceClass);
                    if (hasClass) {
                        console.log(`Invalid: ${sourceClass} already on ${targetDate} in another ring`);
                        return false;
                    }
                }
                
                // Check if target class already exists on source date in other rings
                for (let ring = 1; ring <= 3; ring++) {
                    const ringKey = `ring${ring}`;
                    if (ringKey === sourceRing) continue;
                    const hasClass = schedule[sourceDate][ringKey].some(item => item.class === targetClass);
                    if (hasClass) {
                        console.log(`Invalid: ${targetClass} already on ${sourceDate} in another ring`);
                        return false;
                    }
                }
            }
            
            console.log(`‚úì Valid swap: ${sourceClass} (${sourceItems.length}r) ‚Üî ${targetClass} (${targetItems.length}r)`);
            console.log(`  ‚Üí ${sourceJudgeName} will judge ${targetClass} at source position`);
            console.log(`  ‚Üí ${targetJudgeName} will judge ${sourceClass} at target position`);
            return true;
        }
        
        function swapClasses(sourceDate, sourceRing, sourceClass, targetDate, targetRing, targetClass) {
            const schedule = scheduleResult.schedule;
            
            // Get all items for both classes (with their judges)
            const sourceItems = schedule[sourceDate][sourceRing].filter(item => item.class === sourceClass);
            const targetItems = schedule[targetDate][targetRing].filter(item => item.class === targetClass);
            
            // Remember the judges (they will stay in their positions)
            const sourceJudge = sourceItems[0].judge;
            const targetJudge = targetItems[0].judge;
            
            console.log(`Swapping classes only (judges stay):`);
            console.log(`  Source: ${sourceClass} ‚Üí ${targetClass} (judge ${sourceJudge} stays)`);
            console.log(`  Target: ${targetClass} ‚Üí ${sourceClass} (judge ${targetJudge} stays)`);
            
            // Remove both classes from their current locations
            schedule[sourceDate][sourceRing] = schedule[sourceDate][sourceRing].filter(item => item.class !== sourceClass);
            schedule[targetDate][targetRing] = schedule[targetDate][targetRing].filter(item => item.class !== targetClass);
            
            // Add classes to new locations with ORIGINAL judges
            // Target class goes to source position with source judge
            for (let i = 0; i < targetItems.length; i++) {
                schedule[sourceDate][sourceRing].push({
                    class: targetClass,
                    round: i + 1,
                    judge: sourceJudge  // Source judge stays and judges the incoming class
                });
            }
            
            // Source class goes to target position with target judge
            for (let i = 0; i < sourceItems.length; i++) {
                schedule[targetDate][targetRing].push({
                    class: sourceClass,
                    round: i + 1,
                    judge: targetJudge  // Target judge stays and judges the incoming class
                });
            }
            
            console.log(`‚úì Swap complete: Classes swapped, judges stayed in position`);
        }
        
        // Create a judge dropdown with pursuing indicator
        function createJudgeDropdown(date, ringKey, index, currentJudge, judgeNames, judges) {
            const id = `${date}-${ringKey}-${index}`;
            const schedule = scheduleResult.schedule;
            const ringItems = schedule[date][ringKey];
            const className = ringItems[index].class;
            
            let html = `<select class="judge-dropdown" data-date="${date}" data-ring="${ringKey}" data-index="${index}">`;
            html += '<option value="">-- Select Judge --</option>';
            
            for (const judgeName of judgeNames) {
                const judge = judges.find(j => j.name === judgeName);
                const pursuing = judge.pursuing || [];
                const isPursuing = pursuing.includes(className);
                const selected = judgeName === currentJudge ? 'selected' : '';
                const label = isPursuing ? `${judgeName} ‚ö†Ô∏è` : judgeName;
                
                html += `<option value="${judgeName}" ${selected}>${label}</option>`;
            }
            
            html += '</select>';
            return html;
        }
        
        // Handle judge dropdown changes
        function handleJudgeChange(event) {
            const select = event.target;
            const date = select.dataset.date;
            const ringKey = select.dataset.ring;
            const index = parseInt(select.dataset.index);
            const newJudge = select.value;
            
            // Update the schedule data
            scheduleResult.schedule[date][ringKey][index].judge = newJudge;
            
            // Recalculate grid and summary
            displayGrid();
            displaySummary();
            
            console.log(`Updated ${date} ${ringKey} index ${index} to ${newJudge}`);
        }
        
        function displayGrid() {
            const { schedule, trialDates, classData } = scheduleResult;
            const container = document.getElementById('gridTab');
            
            // Collect class counts
            const grid = {};
            const classOrder = [
                'Patrol 1', 'Detective 2', 'Investigator 3', 'Super Sleuth 4',
                'Private Inv', 'Det Diversions', 'Ranger 1', 'Ranger 2', 'Ranger 3',
                'Ranger 4', 'Ranger 5', 'Dasher 3', 'Dasher 4', 'Dasher 5', 'Dasher 6'
            ];
            
            for (const className of classOrder) {
                grid[className] = {};
                for (const date of trialDates) {
                    grid[className][date] = 0;
                }
            }
            
            for (const date of trialDates) {
                const allItems = [...schedule[date].ring1, ...schedule[date].ring2, ...schedule[date].ring3];
                for (const item of allItems) {
                    if (grid[item.class]) {
                        grid[item.class][date]++;
                    }
                }
            }
            
            let html = '<h2>Round Distribution Grid</h2>';
            html += '<table>';
            html += '<tr><th>CLASS</th>';
            for (const date of trialDates) {
                html += `<th>${date}</th>`;
            }
            html += '<th>TOTAL</th></tr>';
            
            let incompleteClasses = [];
            
            for (const className of classOrder) {
                if (!grid[className]) continue;
                
                html += `<tr><td><strong>${className}</strong></td>`;
                let rowTotal = 0;
                
                for (const date of trialDates) {
                    const count = grid[className][date];
                    rowTotal += count;
                    const cellClass = count > 0 ? 'grid-cell grid-cell-filled' : 'grid-cell';
                    html += `<td class="${cellClass}">${count || ''}</td>`;
                }
                
                html += `<td class="grid-cell"><strong>${rowTotal}</strong></td></tr>`;
                
                // Check if incomplete
                if (classData[className]) {
                    const required = classData[className].rounds;
                    if (rowTotal < required) {
                        incompleteClasses.push({
                            className,
                            required,
                            scheduled: rowTotal,
                            missing: required - rowTotal
                        });
                    }
                }
            }
            
            // Totals row
            html += '<tr style="background: #f4cccc;"><td><strong>TOTAL ROUNDS/DAY</strong></td>';
            let grandTotal = 0;
            for (const date of trialDates) {
                let dateTotal = 0;
                for (const className of classOrder) {
                    if (grid[className]) {
                        dateTotal += grid[className][date];
                    }
                }
                grandTotal += dateTotal;
                html += `<td class="grid-cell"><strong>${dateTotal}</strong></td>`;
            }
            html += `<td class="grid-cell"><strong>${grandTotal}</strong></td></tr>`;
            
            html += '</table>';
            
            // Incomplete classes section
            if (incompleteClasses.length > 0) {
                html += '<div class="incomplete-section">';
                html += '<h3>‚ö†Ô∏è INCOMPLETE CLASSES - MANUAL ENTRY NEEDED</h3>';
                html += '<table>';
                html += '<tr><th>CLASS</th><th>REQUESTED</th><th>SCHEDULED</th><th>MISSING</th></tr>';
                for (const item of incompleteClasses) {
                    html += `<tr><td>${item.className}</td><td>${item.required}</td><td>${item.scheduled}</td><td style="color: #c00000;"><strong>${item.missing}</strong></td></tr>`;
                }
                html += '</table>';
                html += '</div>';
            } else {
                html += '<div class="status-message status-success">‚úì All classes complete!</div>';
            }
            
            // Class-Judge Assignment Section (NEW!)
            html += '<div style="margin-top: 30px;">';
            html += '<h2>Class Assignments by Judge</h2>';
            html += '<table>';
            html += '<tr><th>CLASS</th><th>JUDGES</th><th>ROUNDS</th></tr>';
            
            const judges = scheduleResult.judges;
            
            for (const className of classOrder) {
                // Find all judges who judge this class
                const judgesForClass = new Set();
                const roundsPerJudge = {};
                
                for (const date of trialDates) {
                    const allItems = [...schedule[date].ring1, ...schedule[date].ring2, ...schedule[date].ring3];
                    for (const item of allItems) {
                        if (item.class === className && item.judge) {
                            judgesForClass.add(item.judge);
                            roundsPerJudge[item.judge] = (roundsPerJudge[item.judge] || 0) + 1;
                        }
                    }
                }
                
                if (judgesForClass.size > 0) {
                    const judgeList = Array.from(judgesForClass).sort();
                    const judgeDetails = judgeList.map(j => {
                        const rounds = roundsPerJudge[j];
                        return `${j} (${rounds}r)`;
                    }).join(', ');
                    
                    const totalRounds = Object.values(roundsPerJudge).reduce((a, b) => a + b, 0);
                    
                    html += `<tr><td><strong>${className}</strong></td><td>${judgeDetails}</td><td><strong>${totalRounds}</strong></td></tr>`;
                }
            }
            
            html += '</table>';
            html += '</div>';
            
            container.innerHTML = html;
        }
        
        function displaySummary() {
            const { schedule, trialDates, judges } = scheduleResult;
            const container = document.getElementById('summaryTab');
            
            function getInitials(name) {
                return name.split(' ').map(p => p[0]).join('').toUpperCase();
            }
            
            function getClassesWithCounts(ringItems) {
                const classCounts = {};
                for (const item of ringItems) {
                    if (!classCounts[item.class]) {
                        classCounts[item.class] = 0;
                    }
                    classCounts[item.class]++;
                }
                return classCounts;
            }
            
            let html = '<h2>Judge Assignment Summary <span style="color: #4a86e8; font-size: 14px;">‚óè</span></h2>';
            html += '<p style="font-size: 14px; color: #666; margin-bottom: 20px;">Updates automatically when you make changes</p>';
            
            // Ring 1
            html += '<div class="ring-section">';
            html += '<div class="ring-header">RING 1 - K9 SIDE</div>';
            html += '<table><tr><th>Date</th><th>Judge</th><th>Classes</th></tr>';
            for (const date of trialDates) {
                const judge = schedule[date].ring1.length > 0 ? schedule[date].ring1[0].judge : 'NO JUDGE';
                const initials = judge !== 'NO JUDGE' ? getInitials(judge) : '??';
                const classes = getClassesWithCounts(schedule[date].ring1);
                const classStr = Object.entries(classes).map(([c, count]) => `${c} x ${count}`).join(', ');
                html += `<tr><td>${date}</td><td><strong>${initials}</strong> (${judge})</td><td>${classStr}</td></tr>`;
            }
            html += '</table></div>';
            
            // Ring 2
            html += '<div class="ring-section">';
            html += '<div class="ring-header">RING 2 - INSIDE</div>';
            html += '<table><tr><th>Date</th><th>Judge</th><th>Classes</th></tr>';
            for (const date of trialDates) {
                const judge = schedule[date].ring2.length > 0 ? schedule[date].ring2[0].judge : 'NO JUDGE';
                const initials = judge !== 'NO JUDGE' ? getInitials(judge) : '??';
                const classes = getClassesWithCounts(schedule[date].ring2);
                const classStr = Object.entries(classes).map(([c, count]) => `${c} x ${count}`).join(', ');
                html += `<tr><td>${date}</td><td><strong>${initials}</strong> (${judge})</td><td>${classStr}</td></tr>`;
            }
            html += '</table></div>';
            
            // Ring 3
            html += '<div class="ring-section">';
            html += '<div class="ring-header">RING 3 - PARKING LOT</div>';
            html += '<table><tr><th>Date</th><th>Judge</th><th>Classes</th></tr>';
            for (const date of trialDates) {
                const judge = schedule[date].ring3.length > 0 ? schedule[date].ring3[0].judge : 'NO JUDGE';
                const initials = judge !== 'NO JUDGE' ? getInitials(judge) : '??';
                const classes = getClassesWithCounts(schedule[date].ring3);
                const classStr = Object.entries(classes).map(([c, count]) => `${c} x ${count}`).join(', ');
                html += `<tr><td>${date}</td><td><strong>${initials}</strong> (${judge})</td><td>${classStr}</td></tr>`;
            }
            html += '</table></div>';
            
            // Judge workload - RECALCULATE FROM CURRENT SCHEDULE
            html += '<div class="ring-section">';
            html += '<div class="ring-header">JUDGE WORKLOAD SUMMARY</div>';
            html += '<table><tr><th>Judge</th><th>Days Worked</th><th>Total Rounds</th><th>Pursuing Violations</th></tr>';
            
            // Recalculate everything from current schedule state
            const judgeStats = {};
            
            // Initialize all judges
            for (const judge of judges) {
                judgeStats[judge.name] = {
                    judge: judge,
                    daysWorked: 0,
                    totalRounds: 0,
                    pursuingViolations: 0,
                    datesWorked: new Set()
                };
            }
            
            // Count from actual schedule
            for (const date of trialDates) {
                for (let ring = 1; ring <= 3; ring++) {
                    const ringKey = `ring${ring}`;
                    const ringItems = schedule[date][ringKey];
                    
                    if (ringItems.length > 0) {
                        const judgeName = ringItems[0].judge;
                        
                        if (judgeName && judgeStats[judgeName]) {
                            // Count days worked
                            judgeStats[judgeName].datesWorked.add(date);
                            
                            // Count total rounds
                            judgeStats[judgeName].totalRounds += ringItems.length;
                            
                            // Count pursuing violations
                            const classes = [...new Set(ringItems.map(item => item.class))];
                            const pursuing = judgeStats[judgeName].judge.pursuing || [];
                            const pursuingClasses = classes.filter(c => pursuing.includes(c));
                            judgeStats[judgeName].pursuingViolations += pursuingClasses.length;
                        }
                    }
                }
            }
            
            // Convert datesWorked Set to count
            for (const judgeName in judgeStats) {
                judgeStats[judgeName].daysWorked = judgeStats[judgeName].datesWorked.size;
            }
            
            // Sort judges by days worked (descending), then by rounds
            const sortedJudges = Object.values(judgeStats)
                .filter(stat => stat.totalRounds > 0)
                .sort((a, b) => {
                    if (a.daysWorked !== b.daysWorked) return b.daysWorked - a.daysWorked;
                    return b.totalRounds - a.totalRounds;
                });
            
            // Display judge stats
            for (const stat of sortedJudges) {
                const violationCell = stat.pursuingViolations > 0 
                    ? `<span style="color: #c00000; font-weight: bold;">${stat.pursuingViolations} ‚ö†Ô∏è</span>` 
                    : `<span style="color: #28a745;">0 ‚úì</span>`;
                
                html += `<tr><td>${stat.judge.name}</td><td><strong>${stat.daysWorked}</strong></td><td><strong>${stat.totalRounds}</strong></td><td>${violationCell}</td></tr>`;
            }
            
            // Show judges with zero rounds (not working)
            const notWorkingJudges = Object.values(judgeStats)
                .filter(stat => stat.totalRounds === 0)
                .sort((a, b) => a.judge.name.localeCompare(b.judge.name));
            
            if (notWorkingJudges.length > 0) {
                html += '<tr><td colspan="4" style="background: #f5f5f5; font-weight: bold; text-align: center;">Not Working</td></tr>';
                for (const stat of notWorkingJudges) {
                    html += `<tr style="opacity: 0.5;"><td>${stat.judge.name}</td><td>0</td><td>0</td><td><span style="color: #999;">-</span></td></tr>`;
                }
            }
            
            html += '</table></div>';
            
            container.innerHTML = html;
            
            console.log('üìä Judge Workload Updated:');
            for (const stat of sortedJudges) {
                console.log(`  ${stat.judge.name}: ${stat.daysWorked} days, ${stat.totalRounds} rounds, ${stat.pursuingViolations} violations`);
            }
        }
        
        // Export to Excel
        document.getElementById('exportBtn').addEventListener('click', exportToExcel);
        
        function exportToExcel() {
            const { schedule, trialDates, classData, judges } = scheduleResult;
            
            const wb = XLSX.utils.book_new();
            
            // Schedule sheet
            const scheduleData = [['Date', 'Ring 1', 'Judge', 'Ring 2', 'Judge', 'Ring 3', 'Judge']];
            
            for (const date of trialDates) {
                const daySchedule = schedule[date];
                const maxRows = Math.max(
                    daySchedule.ring1.length,
                    daySchedule.ring2.length,
                    daySchedule.ring3.length
                );
                
                for (let i = 0; i < maxRows; i++) {
                    const row = [i === 0 ? date : ''];
                    
                    if (i < daySchedule.ring1.length) {
                        const item = daySchedule.ring1[i];
                        row.push(`${item.class} Round ${item.round}`, item.judge || 'NO JUDGE');
                    } else {
                        row.push('', '');
                    }
                    
                    if (i < daySchedule.ring2.length) {
                        const item = daySchedule.ring2[i];
                        row.push(`${item.class} Round ${item.round}`, item.judge || 'NO JUDGE');
                    } else {
                        row.push('', '');
                    }
                    
                    if (i < daySchedule.ring3.length) {
                        const item = daySchedule.ring3[i];
                        row.push(`${item.class} Round ${item.round}`, item.judge || 'NO JUDGE');
                    } else {
                        row.push('', '');
                    }
                    
                    scheduleData.push(row);
                }
                
                scheduleData.push(['TIME UNITS', `${daySchedule.ringTimes[1]} units`, '', `${daySchedule.ringTimes[2]} units`, '', `${daySchedule.ringTimes[3]} units`, '']);
                scheduleData.push(['', '', '', '', '', '', '']);
            }
            
            const ws1 = XLSX.utils.aoa_to_sheet(scheduleData);
            XLSX.utils.book_append_sheet(wb, ws1, 'Generated Schedule');
            
            // Download
            XLSX.writeFile(wb, 'trial_schedule.xlsx');
        }
    </script>
</body>
</html>
